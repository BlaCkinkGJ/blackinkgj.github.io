---
layout: post
title: "[소프트웨어 공학] 소프트웨어 품질"
date: 2018-10-23
excerpt: "소프트웨어 품질에 관해서 알아보도록 한다."
tag:
- Software Engineering
comments: true
---

# 소프트웨어 품질

소프트웨어 품질에서는 다음의 3가지가 중요하다고 할 수 있습니다.

1. 소프트웨어가 의도된 대로 동작을 하는가?
2. 소프트웨어가 의도한 서비스 기능을 전체 제공하는가?
3. 소프트웨어가 사용자의 필요를 만족시키는가?

하지만 이를 보고 품질의 정의라고 할 수는 없습니다. 품질의 정의는 DoD[^1], ISO, Kitchenham에 따라서 다 다르기 때문입니다. DoD에서는 1985년 "소프트웨어 속성이 의도한 최종 용도를 수행 할 수 있는 정도"라고 했고, ISO에서는 1987년 "특정할 수 있거나 묵시적인 요구사항을 충족시킬 수 있는 능력을 갖춘 제품 또는 서비스의 전체 기능 및 특징"이라고 했습니다. 나아가 Kitchenham 은 1989년 "요구사항을 잘 따르는 것"이라고 했습니다. 그리고 이러한 소프트웨어 품질을 보는 데는 아래 내용을 유념해야 합니다.

- 품질은 절대적인 척도가 아니다.
- 품질은 여러 척도가 연결되어 있기에 다방면으로 봐야 한다.
- 품질은 어느 특정된 제약 사항이 존재한다.
- 품질은 어떤 사항에 타협하고 인정하는 것에 관한 것이다.
- 품질의 각 요소는 서로에 종속적이다.

이러한 품질은 칼로 잰 것 같이 나누어지지 않지만, 굳이 나눈다면 외부 품질과 내부 품질로 나뉩니다. 먼저 **외부 품질**은 "사용자나 사용자들이 보고 느낄 수 있는 것"으로 시스템에서 사용자들이 볼 수 있는 내용이고, **내부 품질**은 "개발자가 고려할 사항"에 해당하며 <u>외부 품질을 개발자가 달성할 수 있도록 도와줍니다.</u>

여기서 외부적 관점으로 품질을 바라보면 각 대상에 대해서 품질 요구사항은 아래와 같을 수 있습니다.

|    사용자     | 스폰서  | 유지관리자 |
| :-- | :---- | :---- |
|쉬운 사용|낮은 비용|고도의 문서화|
|다양한 기능|높은 생산성|최소의 오류|
|쉽게 배울 수 있음|높은 유연성|좋은 디자인|
|-|-|가독성 있는 코드|
{:.table .table-bordered}

그리고 이 이외 분류로는 제품(product)과 과정(process)에 대한 품질이 있습니다. 제품을 만들기 위해서는 과정을 써야 하고, 과정이 좋으면 제품도 좋게 나올 가능성이 크기 때문에 이 둘은 매우 연관 관계가 깊다고 할 수 있습니다. 여기서 **제품 품질**로는 기능성, 사용 용이성, 효율성, 신뢰성 등이 있습니다. 그리고 **과정 품질**로는 생산성, 방법이나 도구의 효율성, 표준의 사용 정도, 관리 등이 있습니다. 여기서 과정 품질에 좀 더 신경 쓸 필요가 있습니다.

소프트웨어의 품질은 다른 품질의 계측 방법과 다릅니다. 그 이유는 소프트웨어는 물리적으로 존재하는 것이 아니고, 클라이언트들이 시작하는 데 필요로 하는 것에 관한 지식이 부족하고 하드웨어와 소프트웨어의 변화율이 매우 빠릅니다. 그리고 클라이언트들은 결과물에 높은 기대를 합니다. 개중에 특히 융통성(adaptability)에 대한 기대는 남다르게 매우 높습니다.

이러한 품질에 표현되는 내용으로는 **정확성ㆍ신뢰성ㆍ견고성, 성능, 사용자 친화성, 검증성, 유지 보수성, 재사용성, 이식성, 이해 용이성, 상호 운용성, 생산성, 시기 적절성, 시계(視界)성**이 있습니다. 각각의 내용에 관해서 알아보도록 하겠습니다.

## 품질 요소

### 정확성, 신뢰성, 견고성

많은 사람이 헷갈리는 개념입니다. 상호 교환해서 사용할 수 있는 열린 공간입니다. 이 말은 응용 프로그램이 예상대로 기능을 수행하는 정도를 의미합니다. 

#### 정확성

만약 프로그램이 사양(specification)에 있는 기능에 따라 움직인다면 정확(correct)한 것입니다. 이것을 증명하기 위해서는 명세서가 존재해야 합니다. 그리고 명확하게 결정 할 수 있도록 모호한 사양이 있으면 안 됩니다. 그리고 소프트웨어가 완벽하게 정확하다고 말하는 것은 불가능합니다. 왜냐하면, 모든 사항을 다 검증하는 것은 쉬운 일이 아닌 사실상 불가능한 일이나 다름없기 때문입니다. 

#### 신뢰성

의존성(dependability)이라고도 말합니다. 만약 사용자가 프로그램에 의존한다면 믿을만하다고 할 수 있습니다. 예를 들어, 문서를 작업하는 데 MS워드를 사용하는 게 편하다고 생각하는 경우 "MS 워드에 문서 작업을 **의존한다**"라고 말할 수 있고" MS워드를 문서 작업 하는 데에 있어 **신뢰한다**"라고 말할 수 있습니다.

제품에서 발생하는 실패[^2]의 빈도와 실패에 따른 위험성 정도를 통해 신뢰성은 측정됩니다. 예를 들어, 덧셈 연산을 만드는 경우 $$1+5=6$$이 나오면 실패 빈도가 없으므로 신뢰할 수 있겠다고 할 수 있고 $$1+5=8$$이 나올 때도 '오차가 2 정도 발생할 수 있다'라고 한 경우에는 이 또한 신뢰할 수 있겠다고 할 수 있습니다. 행위에 대해 통계적으로 낸 결과에 대한 용어로는 MTTR, MTTF, MTBF가 있습니다.

|    항목     | 내용  |
| :--: | :---- |
|MTTR|고치는 시간의 평균을 낸 것|
|MTTF|다음 정상까지의 시간|
|MTBF|실패와 실패 사이의 시간|
{:.table .table-bordered}

여기서 알아야 할 것은 정확성은 **절대적인 척도**에 비해서 신뢰성은 **상대적인 척도**에 가깝습니다.

#### 내구성

사양 요구서에서 예상한 환경에서 잘 동작할 뿐만 아니라 예상되지 않은 환경에서도 정상적으로 돌아간다면 내구성(robustness)이 좋다고 할 수 있습니다. 여기서 고려되는 사항으로 소프트웨어가 유지(변경) 또는 의도하지 않은 부작용이 발생할 때도 따로 신경 쓰지 않아도 디버깅이나 수정을 할 수 있는가? 이러한 수정이 오류율이나 시간, 신뢰에 악영향을 끼치는가? 등이 있습니다.

이러한 품질 간의 관계를 살펴보면 아래와 같이 됨을 알 수 있습니다.

![factor](\assets\img\res\2018-SoftEng\2\factor.png)

### 성능

성능(performance)은 효율성(efficiency)이라고 볼 수 있습니다. 이런 성능에서 중시되는 건 시간 효율성과 공간 효율성입니다. 이는 시스템의 가용성에 영향을 끼칩니다. 성능은 <u>감시를 통한 측정, 분석, 시뮬레이션</u>을 통해서 측정됩니다. 여기서 시뮬레이션의 정확성은 감시를 통한 측정보다는 부정확하지만, 분석보다는 정확한 방법이라고 할 수 있습니다. 이러한 성능의 측정은 개발 후보다 **개발 전에** 수행해야 합니다. 그리고 우리는 어느 정도의 퍼포먼스가 나올 것인지 늘 예측해야 합니다. 이러한 응용 프로그램의 처리 성능을 보고 **생산성(productivity)**이라고 합니다.

### 사용자 친화성

사용자 친화성(user friendliness)은 사용자가 사용하는 데 얼마나 편한가에 있습니다. 이러한 사용자 친화성이 높다면 시스템을 쉽게 하드웨어 환경에 맞게 적용 및 구성할 수 있습니다.

### 검증성

시스템의 속성이 안전하게 검증될 수 있다면 검증 가능하다고 할 수 있습니다. 이러한 검증은 각 단계에 대해서 수행하며 규격화된 분석 방법을 많이 사용합니다.

### 유지 보수성

소프트웨어의 유지보수(Maintainability)는 하드웨어의 유지보수랑은 전혀 다릅니다. 이런 유지보수에서는 아래와 같은 사항들이 진행됩니다.

1. 시스템의 수정 작업 : 시스템 오류 같은 것을 수정하는 과정입니다.
2. 시스템의 호환성 확대 작업 : 이는 윈도 프로그램을 맥에도 이식하는 작업에 해당합니다.
3. 좀 더 완전하게 만드는 작업 : 기능을 수정한다던가 성능을 높이던가 해서 더 시스템을 완벽하게 만듭니다.

이 중 가장 중요한 것은 '작업 3'입니다. 일반적으로 작업 1, 2가 유지보수에서 20%, 20%를 차지한다면 작업 3은 이거 하나로 전체의 60% 정도를 차지합니다. 이러한 이유로 인해서 소프트웨어는 계속해서 진화하게 됩니다. 결과적으로, 이런 유지보수 과정에 의해서 소프트웨어는 스스로 수정 가능(repairability)하고 진화 가능(evolvability)해지게 됩니다.

여기서 **수정 가능성**은 '소프트웨어를 제한된 양의 작업으로 잘못된 점을 수정하는 것이 가능한가?'를 의미합니다. 적합한 도구의 사용을 통해서 수정 가능성을 높일 수 있습니다. 그리고 **모듈화(Modularization)**가 이러한 수정 가능성을 높이는 매우 좋은 방법의 하나입니다.

그리고 **진화 가능성**은 '소프트웨어가 새로운 요구사항을 만족할 수 있도록 변경을 하는 것'을 의미합니다. 이는 수정이 동반되는 데 일반적으로 새로운 기능이 제공되고, 현존하는 기능은 변화가 일어나게 됩니다. 이를 달성하기 위해서 **재구조화**(restructuring) 및 **재설계(re-engineering)**가 일어나게 됩니다.

### 이식성

이식성(portability)은 서로 다른 환경에서 돌아갈 수 있음을 의미합니다. 여기에 해당하는 서로 다른 환경은 소프트웨어 환경이 될 수도 하드웨어 환경이 될 수도 있습니다.

### 이해 용이성

이는 상품의 내부적인 품질이라고 생각할 수 있습니다. 일반적으로 시스템이 이해하기 편하면 사용하기도 편해지게 됩니다. 그리고 내부적인 품질이라는 것은 많은 다른 품질을 달성하는 데 도움을 줄 수 있다는 것을 의미합니다. 그중 유지보수에 큰 영향으로 쉽게 유지보수를 할 수 있게 만들어 줍니다. 이를 외부적인 관점에서 본다면 동작이 예측한 대로 동작하는 것이라고 할 수 있습니다. 이러한 이해 용이성은 객체 지향 패러다임에 의해서 달성될 수 있습니다.

### 상호 운용성 

다른 시스템과 함께 존재하고, 협력하는 능력을 의미합니다. 이것이 오픈 시스템의 기본 개념이 됩니다. 이러한 상호 운용성이 부족하면 오픈 시스템이라는 것이 전혀 의미가 없게 될 가능성이 큽니다.

### 생산성

소프트웨어 생산 과정의 품질을 의미합니다. 이것은 얼마나 과정이 효율적인지를 바탕으로 측정이 됩니다. 하지만 실질적인 측정은 매우 어렵습니다. 그래서 일반적으로 사용하는 방법이 LOC(Lines of Code)를 사용해서 효율성을 판단하지만 정확한 측정 방법은 아닙니다. 그리고 이런 생산성은 도구를 사용해서 증대시킬 수 있습니다.

### 시기 적절성

시기 적절성(Timeliness)은 과정과 유관한 내용으로 상품을 제시간에 보내는 능력과 관계된 요소입니다. 이를 달성하기 위해서는 아래의 3가지를 유념해야 합니다.

1. 계획표를 유의 깊게 확인합니다.
2. 작업 예측을 정확하게 하도록 합니다.
3. 마일스톤을 명확하게 특정하도록 합니다.

끝을 내고 보내는 것이 아니라 중간마다 계속 보내어서 이를 달성할 수 있도록 합니다.

### 시계성

시계성(visibility)도 과정과 연관된 내용으로 '시스템의 현재 개발 단계와 상태가 문서화 되어 있는가'와 관련 있습니다. 이는 작업자들에게 업무량을 적절하게 부여할 수 있도록 해줍니다.

## 응용 프로그램별 품질 요구사항

정보, 실시간, 분산, 임베디드 시스템에 따라서 품질 요구사항은 서로 다를 수 있습니다. **정보 시스템**의 경우 데이터를 저장하고 받는 것에 큰 중점이 있습니다. 일반적으로 비지니스 영역의 요구사항이 많습니다. 예를 들어, 은행 시스템, 도서관 카탈로그 시스템 등이 있습니다. 대표적인 품질 요구사항으로는 데이터 통함, 유용, 트랜섹션 성능, 보안, 사용자 인터페이스 등이 있습니다.

**실시간 시스템**의 경우 제한된 시간 안에 돌아가야 할 필요가 있는 시스템입니다. 예를 들어, 공장 감시 시스템, 미사일 가이드 시스템, 마우스 핸들링 시스템 등이 있습니다. 그리고 이러한 시스템은 제어에 기반을 두어 동작을 하게 되고, 마감과 우선순위와 관련된 스케쥴링이 매우 중요합니다. 그리고 이런 실시간에서도 엄격한(Hard) 실시간 시스템과 느슨한(Soft) 실시간 시스템으로 나뉘는 데, 전자는 시간을 반드시 지켜야 하는 것에 해당하고 후자는 약간은 느슨해도 상관없습니다. 이런 시스템에서 주로 요구하는 품질로는 정확성(correctness)과 관계된 시간 관련한 요구사항입니다.

**분산 시스템**에서 분산은 정도에 따라서 데이터, 제어, 하드웨어로 나뉘게 됩니다. 예를 들어, 클라이언트-서버 시스템의 미들웨어[^3]라던가 그룹웨어에 해당합니다. 이런 시스템에서 시스템 가용성(availability)을 주로 요구합니다.

**임베디드 시스템**에서는 소프트웨어는 많은 구성요소 중 하나일 뿐이고, 엔드 유저를 위한 인터페이스는 따로 존재하지 않습니다. 예를 들어, 비행기, 로봇, 전자 오븐, 식기세척기, 자동차 등이 있습니다.

결과적으로, 시스템마다 고려해야 할 사항은 다름을 알고 작업을 진행해야 함을 알 수 있습니다.

---

[^1]: 美 국방성(Department of Defense)
[^2]: 허용 가능한 실행 조건 아래에서 결과 또는 행위가 이해할 수 없는 경우를 지칭합니다.
[^3]: 대학교 내부 네트워크 같은 것이 대상입니다.