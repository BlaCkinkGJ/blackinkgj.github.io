---
layout: post
title: "[소프트웨어 공학] 소프트웨어 프로세스"
date: 2018-10-23
excerpt: "소프트웨어 프로세스에 관해서 알아보도록 한다."
tag:
- Software Engineering
comments: true
---

# 소프트웨어 프로세스

소프트웨어 공학은 계층형(layered) 기술이라고 할 수 있습니다. 가장 기본이 되는 것이 품질입니다. 그리고 프로세스(process)는 소프트웨어 공학의 기반이라고 할 수 있으며, 방법(method)은 기술적으로 "어떻게(How-To)"와 관련된 내용을 의미하고, 도구는 프로세스와 방법을 자동화하기 위한 보조 내용입니다.

![Layer](/assets/img/res/2018-SoftEng/3/layered.png)

그리고 이러한 소프트웨어 프로세스는 아래와 같은 프레임 워크로 구성됩니다.

![phases](/assets/img/res/2018-SoftEng/3/phases.png)

각 단계(phase)에 관해서 알아보도록 하겠습니다. 먼저 **정의(definition) 단계**에서는 "무엇을(What)"에 중점을 두는 과정으로 핵심적인 요구사항을 파악하는 과정입니다. 이때 주요 작업으로는 시스템 및 정보를 설계, 프로젝트를 계획하고 일정을 잡는 등의 프로젝트 관리 및 요구사항 분석을 진행하도록 합니다.

그리고 **개발(development) 단계**에서는 "어떻게(How)"에 중점을 두는 과정으로 문제의 해결책을 어떻게 만들 것인가를 생각하는 과정입니다. 주요 작업으로는 소프트웨어 설계 및 코드 생산, 소프트웨어 테스트가 진행되게 됩니다.

마지막으로 **유지관리(maintenance) 단계**에서는 "변화(Changes)"에 중점을 두는 과정입니다. 이에 접근할 때에는 잘못을 바로잡는 정확성(correctness), 외부 환경과 비지니스 규칙에 적응하는 적응성(adapting), 추가적인 기능의 추가로 인해 발생하는 향상성(enhancement)을 잘 신경 쓰도록 해야 합니다.

여기서 좀 더 나아가서 **우산 동작(umbrella activities)**이 있습니다. 이는 주요 동작을 지원하는 동작을 의미합니다. 즉, 위에서 언급한 정의, 개발, 유지관리 단계를 좀 더 효과적으로 진행하기 위해 만들어진 개념이라고 생각하시면 됩니다.

## CMMI

우리는 조직이 어느 정도의 능력을 갖추고 있는지 평가할 필요가 있습니다. 이를 평가하기 위해서 CMIM(Capability Maturity Model Integration)이라는 평가 방법이 있습니다. 이 방법은 카네기 멜런 대학의 소프트웨어 공학 기관에서 개발이 되었으며 조직이 프로세스를 운영할 수 있는지 확인하는 방법입니다. 이러한 프레임워크는 효율적인 소프트웨어 프로세스의 키가 되는 요소를 가지며, 이를 KPA(Key Process Area)라고 합니다. 결과적으로, 프레임워크는 조직의 프로세스 수행 능력을 앞서 설명한 키 프로세스의 수행 여부를 바탕으로 확인하도록 합니다.

이러한 소프트웨어 프로세스의 단계는 아래와 같이 구성됩니다.

![CMMI](/assets/img/res/2018-SoftEng/3/CMMI.png)

각 단계를 정리하면 아래와 같이 정리할 수 있습니다.

|단계|    항목     | 내용  |
|:--:| :--: | :---- |
|1|초기<br />(Initial)|프로세스가 없이 한 사람의 능력에 따라 퀄리티가 달라지는 상태|
|2|반복<br />(Repeatable)|조직 프로젝트에 관한 프로세스가 존재하고<br />같은 프로젝트에는 같은 프로세스를 사용할 수 있는 단계|
|3|정의<br />(Defined)|조직 운영에 대한 프로세스가 존재하는 단계<br />즉, 교육ㆍ훈련을 할 수 있는 능력을 갖춘 단계|
|4|관리<br />(Managed)|조직 내 각 부서 성공률과 같은 수치적인 내용을<br />예측할 수 있는 능력을 갖춘 단계|
|5|최적화<br />(Optimizing)|계속 어떤 것을 개선해나가 최적의 결과를<br />도출할 수 있는 프로세스를 가지고 있는 단계|
{:.table .table-bordered}

여기서 가장 바람직한 단계는 5단계라고 볼 수 있습니다. 그리고 이러한 각각의 단계는 하위 단계를 포함합니다. 그리고 이러한 CMMI 말고도 유럽에서는 SPICE(Software Process Improvement and Capability Determination)이라는 방법이 있습니다.

## 프로세스 모델

소프트웨어 프로세스는 일종의 소프트웨어 개발을 할 때의 사람들에 지시하는 내용의 집합입니다. 이들 주요 내용으로 동작, 방법, 훈련에 관한 내용이 기술됩니다. 이러한 프로세스의 품질은 결과물(product)의 품질에 지대한 영향을 끼칩니다. 프로세스 모델을 사용하게 되면 서로를 이해하며 의사소통하는 것을 촉진하고 프로세스의 진전과 관리에 도움을 주며 기술과 과정에 대한 통합된 도구를 제공하게 됩니다.

이러한 소프트웨어 프로세스에는 **소프트웨어 생명 주기(Software Life Cycle)**가 존재합니다. 이는 소프트웨어가 생겨나서 사라질 때까지의 주기를 의미합니다. 즉, 동작들이 시간의 어떤 순서대로 흘러가는가와 관련이 있는 내용이라고 할 수 있습니다.

이제 프로세스 모델을 알아보겠습니다. 프로세스 모델에는 Build and Fix, Linear Sequential (Waterfall), Prototyping , RAD , Evolutionary (Incremental , Spiral , WINWIN Spiral ),  Component-Based Development, Formal Methods , Fourth Generation Techniques 등이 있습니다. 각각을 살펴보도록 하겠습니다.

### Build-and-Fix Model

이 방식은 일반적인 학부생들이 사용하는 방법으로 아주 간단한 것을 만들 때 좋은 방법입니다. 먼저 첫 번째 버전을 만들고 클라이언트가 만족하는지 확인을 하도록 합니다. 만족하는 경우에는 제품이 출하되고 그렇지 않은 경우는 클라이언트가 만족할 때까지 계속 수정해나갑니다. 그리고 만약에 유지보수 상황이 벌어지면 다시 수정 위치로 돌아가서 수정을 계속하는 방법론입니다. <u>이 경우 분석 설계는 첫 번째 버전을 만들 때 이루어지게 됩니다.</u>

![Build and fix](http://2.bp.blogspot.com/-25hEVsOTRvM/T5hC50CmTsI/AAAAAAAAAAM/uP0Z3dc1FCQ/s1600/BuildAndFix.gif)

이 방법의 특징을 정리하면 아래와 같습니다.

1. 혼자 개발을 할 때 편합니다.
2. 명세서 없이도 개발할 수 있습니다.
3. 매우 작은 개발을 할 때 사용됩니다.

이 방식은 오늘날 환경에서는 별로 선호되지 않는 방법입니다. 그 이유는 **협업이 사실상 불가능**하기 때문입니다.

### Linear Sequential Model

소프트웨어 개발을 일련의 순서로 접근하는 방식으로 "고전 생명 주기", "폭포수 모델"이라고 부릅니다.

![waterfall model](http://2.bp.blogspot.com/-y3bWi14Cd-M/T7Tu0FUit8I/AAAAAAAAAEw/GyGFuVcH2MM/s1600/Capture.PNG)

이러한 모델을 폭포수 모델이라 하는 이유는 흡사 폭포수가 떨어지는 그것처럼 작업이 이루어지기 때문입니다.

![waterfall](/assets/img/res/2018-SoftEng/3/waterfall.png)

초창기는 위의 그림에서 보이는 것과 같았지만 현대에 들어서는 거슬러 올라가는 모형도 등장하였습니다. 이것에 관해서는 뒤에서 살펴보도록 하겠습니다. 이 모델은 1970년에 유행한 방식으로 많은 산업체에서 표준적으로 도입하는 모델입니다. **문서화가 매우 중요한** 특징을 가지고 있으며, 1개 단계의 출력은 다음 단계의 입력이 되는 방식입니다. 그리고 이러한 출력은 **문서**의 형태로 나타나게 됩니다. 앞서 이야기하였듯이 워낙 유명한 모델이다 보니 많은 변형 모델이 존재합니다. 다음은 각 동작 별 출력 문서들을 정리한 표입니다.

|Activity|    Output documents     |
|:---| :--- |
|Requirements Analysis|Feasibility[^1] study, Outline requirements|
|Requirements Definition|Requirements document|
|System Specification|Functional specification, Acceptance test plan draft user manual|
|Architectural Design|Architectural specification, System test plan|
|Interface Design|Interface specification, Integration test plan|
|Detailed Design|Design specification, Unit test plan|
|Coding|Program code|
|Unit Testing|Unit test report|
|Module Testing|Module test report|
|Integration Testing|Integration test report, Final user manual|
|System Testing|System test report|
|Acceptance Testing|Final system plus documentation|
{:.table .table-bordered}

여기서 단계별 관점을 정리하면 아래와 같이 정리할 수 있습니다.

![overview](/assets/img/res/2018-SoftEng/3/overview.png)

여기서 모형화할 때 사용하는 대표적인 언어로는 UML이 있습니다. 그리고 CASE 도구나 프로그래밍 도구 같은 경우 요즘은 통합된 것이 많습니다. 그것들을 사용하면 좀 더 업무 효율을 높일 수 있습니다. 이런 것을 보고 seamless라고 합니다.

#### Feasibility Study

이 프로젝트가 드는 **돈하고 이점**이 무엇인지를 파악하는 과정입니다. 일반적으로 회사의 결정권자 혹은 기획부서에서 진행하는 내용입니다. 일반적으로 <u>문제에 대한 정의, 예상되는 이점과 대안 해결책, 필요로 하는 자원과 비용, 내는 기간 일자</u>들이 문서로 나옵니다.

#### Requirement Analysis and Specification

프로그램이 필요로 하는 품질 요구사항을 알아내도록 합니다. **기능적인 것과 비기능적인 것**을 구분하도록 합니다. 대부분의 서술은 무엇을 해야 할지가 되어야지 어떻게 해야 할지가 되어서는 안 됩니다. 고객과 설계자가 둘 다 공유되는 내용입니다. 기술적인 관점은 3가지로 나뉠 수 있습니다. 데이터의 모델 : E-R 다이어그램

1. 기능의 모델 : 데이터 흐름 다이어그램
2. 제어의 모델 : 제어 흐름 다이어그램, Petrinets

#### Design and Specification

문제에 대한 해결책을 제시합니다. 고수준과 저수준으로 나뉘며 **고수준**은 전체 예비 설계 과정으로 시스템을 모듈 단위로 나누고 모듈 간에 연결을 특정합니다. **저수준**에서는 각 모듈에 대한 세부적인 설계를 진행하도록 합니다. 설계적 관점으로는 데이터, 제어, 외부 인터페이스, 사용자 인터페이스가 중점이 됩니다.

#### Coding and Module Testing

프로그래밍 언어를 사용해서 개발하는 부분입니다.

####  Integration and System Testing

컴포넌트를 모아서 하나의 프로그램으로 만드는 과정입니다. 통합 테스트 과정에서는 모듈 간 통합 시에 발생하는 내용에 대해서 중점으로 보도록 하고, 시스템 테스트 과정에서는 기능적인 품질과 비기능적인 품질에 대한 평가에 중점을 두도록 합니다.

#### Delivery and Maintenance

유지보수의 종류로는 정확성(corrective), 적응성(adaptive), 완전성(perfective)으로 구성되며 각각 20%, 20%, 60%의 비율을 차지하고 있습니다. 그리고 주의해야 할 사항으로는 간단한 모듈도 오류가 발생할 수 있음을 상기해야 합니다. 왜냐하면, 모든 경우에 대해서 실행을 해보지 못했기 때문입니다.

#### other

나머지 작업으로는 **문서화, 검증, 관리** 작업이 있습니다. 먼저 **문서화**는 전체 프로그램 제작이 30일이 주어진다면 20일을 개발하고 10일은 문서화에 쓴다고 생각하면 될 정도로 중요합니다. **검증**은 프로그램의 품질을 검사하고, 각 단계가 잘 작동하는지 확인하는 작업입니다. 이를 수행하는 방법으로는 검토(Review), 실제 사용(walk-through), 감사(inspection)를 통해서 할 수 있습니다. 마지막 **관리**를 하기 위해서는 프로세스를 따라가면서 정책을 정의하고 프로세스에 영향을 끼치는 모든 자원을 다루도록 해야 합니다.

### Linear Sequential Model의 특징

이 모델의 특징으로는 먼저 개발의 진행이 분석부터 코딩까지 **선형적(linear)**으로 진행되는 점입니다. 그리고 다음 단계로 가기 전에 그 이전 단계 과정이 완전히 **엄격하게(Rigid)** 끝나야 수행 가능합니다. 그리고 **하나의(Monolithic)** 목표를 향해서 달려가도록 해야 합니다. 또한, 계획적이고 체계적인 방법으로 프로젝트가 잘 될 수 있도록 **기여(contribution)**를 합니다. 하지만 이것도 초기에 나온 방법이다 보니 완전무결하다고 할 수는 없습니다. 이를테면 이 모델은 자원을 정확하게 예측하기가 어렵다는 것입니다. 그리고 고객이 효과적으로 요구사항 및 명세서에 대해 검증을 할 수 없고, 사용자는 정확한 요구사항을 모를 수 있습니다. 모든 요구사항이 늘 명시적으로 표현되지는 않습니다. 또한, 변경에 대한 스트레스 테스트를 진행하지 않습니다. 또한, 매우 관료적인 작업 방식이 되며, 실제 프로젝트는 드물게 순서를 따릅니다. 고객은 반드시 참을성이 있어야 합니다. 그리고 이 방식은 개발자들이 자주 불필요할 정도로 지연을 시키는 점입니다.

### Prototyping Model

이 모델은 폭포수 모델의 단점을 해소해보자는 판단에 나오게 되었습니다. Linear Sequential Model은 작업 절차가 진행 중에는 수정이 발생하지 않음에서 착안했습니다. 가장 처음에 **프로토타입(prototype)**을 만드는 과정을 반복해서 해서 변화하는 요구사항을 대처할 수 있도록 하였습니다. 여기서 프로토타입은 약간의 주요기능만을 가진 프로그램을 의미합니다. 

![proto](/assets/img/res/2018-SoftEng/3/proto.png)

이 방식의 **장점**은 매우 현실적이고 명백한 방법이라는 것입니다. 그리고 정확하고 세밀한 요구사항을 추출할 수 있으므로 클라이언트는 본인이 원하는 프로그램을 받을 수 있습니다. 그리고 하나의 프로토타입을 보기 때문에 공통적인 기준점이 생기게 됩니다. 그리고 클라이언트에게 이 프로젝트에 참여하고 있다는 느낌이 들게 만듭니다.

**단점**으로는 프로토타입을 보고 저게 진짜 결과물이라 생각해서 개발 일정을 당기는 문제가 발생할 수 있습니다. 또한, 프로토타입을 보고 기능이 너무 적다 오판하여 기능을 계속 추가하는 문제가 발생할 수 있습니다. 그리고 관리와 제어를 하는 데 더욱더 어려워지게 됩니다.

### RAD

RAD는 Rapid Application Development, 고속 프로그램 개발 모델로 소프트웨어를 빠르게 제작하기 위한 모델입니다. 최대한 각각의 모듈이 독립적으로 돌아갈 수 있도록 모듈화를 시켜주어야 합니다. 만약에 이런 모듈화가 똑바로 되지 않으면 문제가 발생할 수 있습니다. 그리고 각각의 주요기능은 분리된 RAD 팀에 전달되게 됩니다. 단점으로는 크고 추후 확장되는 사업 같은 경우 RAD는 충분한 인적 자원을 필요하므로 인적 자원에 드는 비용이 많이 들어가게 됩니다. 또한, 속도가 너무 빨라서 프로그램 동작의 큰 책임감이 필요하게 됩니다. 아래 그림에서 각 팀은 서로 다른 모듈을 **독립적**으로 제작합니다.

![RAD](https://www.tutorialride.com/images/software-testing/rad-model.jpg)

### 진화 프로세스

**순환 프로세스(iterative process)**가 있습니다. 이런 방법이 나온 이유는 한 번에 각각의 과정이 완벽하게 되는 경우가 없다 보니 그 과정을 반복적으로 수행하여 정확한 요구사항과 그에 따른 소프트웨어 개발을 할 수 있습니다. 그리고 이러한 순환 프로세스를 개선 시킨 게 **향상형(increment) 모델**입니다. 선형 순차 모델(Linear Sequential Model)에 프로토타입 모델을 병합하고 각 단계에서 소프트웨어가 조금씩 발전해 나가는 모델이라고 생각하면 됩니다. 이때, "중요시해지는 내용은 얼마나 그 안에 만들고자 하는 기능이 들어가는가?"입니다. 그리고 첫 번째 향상을 보고 핵심 상품(core product)이라고 합니다. 이 또한 직원이 충분하지 않았을 때 사용하는 방법입니다. 적은 인원을 똑같은 일에 계속해서 투입해서 사람의 기계화를 꾀하도록 합니다.

<img src="https://slideplayer.com/slide/7455121/24/images/9/Incremental+Model+%28Diagram%29.jpg" width="50%">

그리고 이것의 전반적인 모델의 모습은 Build-and-Fix 모델과 유사합니다. 계획이 잘 돌아가면 향상형 모델이라고 할 수 있지만 **<u>만약 삐걱대면 바로 Build-And-Fix 모델로 변질할 수 있으므로 주의하도록 해야 합니다.</u>** 이러한 향상형 모델에는 핵심 작업 흐름도라고 아래 그림과 같은 것이 있습니다.

![increment](http://www.interface.ru/rational/rup51/manuals/intro/images/humporg.gif)

일반적으로 핵심 작업 흐름을 반복적으로 수행하고 단순히 수행만 하는 것이 아니라 **어느 부분이 주로 많이 수행**이 되는가에 따라서 전혀 다른 과정으로 치부되게 됩니다. 위에서 보이면 알겠지만, 핵심 작업 흐름이 끝날 때마다 향상(increment)이 발생하는 것을 알 수 있습니다.

이 방식은 **단계별 개발 방법론**으로 반드시 각 빌드에 폭포수 모델을 적용할 수 있도록 해야 합니다. 전체 생명 주기에도 이 방식을 도입할 수 있습니다. **장점**으로는 사용자가 시스템에 적응하는 시간을 줄일 수 있으면서 변화를 수용하기가 유용합니다. 또한, 한꺼번에 많은 돈이 투자되지 않습니다. **단점**으로는 현재 구조에 각각 추가적인 빌드 과정을 넣어서 통합해주어야 합니다. 매우 조심스러운 설계가 요구됩니다. 만약 잘못된 추가가 발생하게 될 때 유지보수의 난이도가 엄청나게 어려워질 수 있습니다.

### 나선형 모델

초기 출시가 적합한 모델 또는 프로토타입이라 보는 것입니다. 프레임 워크는 고객과의 소통, 계획, 위험(risk) 분석, 설계, 생성 및 출시, 고객의 평가 동작이 있습니다.

![spiral](https://i0.wp.com/softwaretestingbooks.com/wp-content/uploads/2016/03/Spiral_Model.jpg?w=705)

이 방식을 쓰게 되면 시간이 지나면 지날수록 프로그램의 크기가 커지게 됩니다. 이것이 기존 방법과 다른 점은 기존은 **개발**에 초점을 맞춥니다. 하지만 저희는 **위험(risk)**에 초점을 맞추는 방식입니다. 이러한 나선형 모델은 전체 생명 주기에서 채택되었습니다. 이것의 **장점**으로는 **위험이 줄일 수 있다.**, **거대한 크기의 시스템 접근에 있어서 현실적인 접근법이다**의 2가지가 있습니다. 하지만 단점으로는 제어가 어렵고 고객을 이해시키기가 어렵습니다.

#### WIN WIN 나선형 모델

이런 나선형 모델 중에서는 WIN WIN 나선형 모델이 있습니다. 이 모델은 개발자와 소비자가 다 만족할 수 있는 모델을 만들겠다는 일념하에서 나타나게 되었습니다. 

![WINWIN](http://3.bp.blogspot.com/-RKqMv9-0d_E/T7ZLf8if5GI/AAAAAAAAAFk/SSzXI8EeQ5w/s1600/Capture.PNG)

여기서 1에서 stakeholders는 현재 제작 중인 소프트웨어와 관련 있는 모든 사람을 지칭합니다. 그리고 3을 주의해서 진행해야 합니다. 왜냐하면, stakeholders가 제시하는 조건이 충돌을 할 수 있기 때문입니다.

### 컴포넌트 기반 개발

이 방식은 나선형 모델을 바탕으로 두는 개발 방식입니다. 애플리케이션을 객체나 클래스 단위의 컴포넌트(Component)로 구성을 하도록 합니다. 이렇게 하면 나중에 새로운 유사 프로젝트를 진행할 때 매우 높은 수준의 컴포넌트 재사용을 할 수 있습니다. 하지만 원하는 컴포넌트를 찾는 것은 매우 힘들다는 것이 단점입니다. 왜냐하면, 컴포넌트의 단위가 너무 작기 때문입니다. 그래서 사실상 컴포넌트를 효과적으로 사용하려면 HP와 같이 크게 변경되지 않는 프린터 제작이나 이런 것을 할 때 사용하기 좋은 방법론입니다. 여기까지 도달하는 데 구조적 방법에서, 객체 지향을 걸쳐서 도달했습니다. 현대는 이러한 컴포넌트 기반에 서비스 기반 방법론도 함께 들어갑니다.

### Formal Methods Model

수학적인 방법을 통해서 소프트웨어를 작성하는 방법입니다. 이 방법을 사용하게 되면 매우 정확한 명세서를 작성할 수 있으며 해당 내용에 대해서 수학적인 검증이 가능합니다. 하지만 해당 수학적 지식이 없으면 전혀 사용하지 못한다는 것이 단점입니다.

---

[^1]: 실현 가능성