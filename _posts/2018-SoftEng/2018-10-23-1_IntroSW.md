---
layout: post
title: "[소프트웨어 공학] 소프트웨어 공학 개요"
date: 2018-10-23
excerpt: "소프트웨어 공학 전반에 관해서 알아보도록 한다."
tag:
- Software Engineering
comments: true
---

# 소프트웨어 개발

소프트웨어 개발은 아래와 같은 방식으로 이루어지게 됩니다.

![dev](/assets/img/res/2018-SoftEng/1/dev.png)

각각의 단계를 간략하게 살펴보면 아래와 같이 정의할 수 있습니다.

|     항 목     | 내 용                                                        |
| :-----------: | :----------------------------------------------------------- |
| 요구사항 분석 | "고객의 요구가 무엇인가?"<br />"내가 만들어야 하는 것이 무엇인가?"<br />이 둘을 파악하는 **이해의 과정**이라고 할 수 있습니다. |
|     설계      | "어떻게 문제를 풀 것인가?"<br />이것을 파악하는 **문제를 푸는 과정**입니다. |
|     구현      | 문제를 푼 내용을 컴퓨터가 해석 할 수 있도록<br />**코딩하는 과정**입니다. |
|    테스팅     | 일반적으로 사용 소프트웨어는<br />가능한 모든 데이터를 처리해봐야 합니다.<br />이 과정에서 소모되는 기간은 꽤 깁니다. |
|   유지보수 | 대부분의 비용이 발생하는 부분으로<br /> 초기 설계가 잘못하면 기하급수적으로 비용이<br /> 발생하는 부분입니다. |
{:.table .table-bordered}

그리고 이런 개발에서 중요한 내용은 요구사항이 똑같더라도 그 구현은 개발자의 역량에 따라서 달라질 수 있습니다. 예를 들어, 최댓값을 뽑는 기능을 요구받으면 A, B, C의 설계를 보여드리겠습니다.

```c
// A
int max(int val_a, int val_b, int val_c){
    int max, mid, min;
    
    if(val_a > val_b){
        max = val_a;
        min = val_b;
    }else{
        max = val_b;
        min = val_a;
    }
    
    if(max > val_c){
        if(val_c > min){
            mid = val_c;
        }else{
            mid = min;
            min = val_c;
        }
    }else{
        max = val_c;
        mid = max;
    }
    return max;
}

// B
int max(int a, int b, int c){
    int max;
    
    max = a > b ? a : b;
    max = max > c ? max : c;
    
    return max;
}

// C
int max(int a, int b, int c){
    int max;
    
    if((a > b) && (a > c)){
        max = a;
    }else if((b > a) && (b > c)){
        max = b;
    }else{
        max = c;
    }
    return max;
}
```

결과만 보면 3개는 전부 요구사항을 제대로 이행을 합니다. 하지만 그 내부의 구현은 다릅니다. 이렇게 같은 요구사항을 받았음에도 구현이 다를 수 있음을 인지해야 합니다.

# 소프트웨어 공학?

## 배경

소프트웨어 공학의 탄생은 1960년대로 거슬러 올라갑니다. 1960년 상황을 서술하면 아래와 같았습니다.

- 소프트웨어 개발에서 시간, 노력, 비용을 예측을 구성하는 능력이 없었습니다.
- 시장에 나오는 소프트웨어의 품질이 좋지 못했습니다.
- 소프트웨어의 비용이 하드웨어 비용의 비율을 추월하기 시작했습니다.[^2]
- 유지보수[^1]의 역할이 중요해지기 시작했습니다.
- 하드웨어가 혁신에 혁신을 거듭하고 있었습니다.
- 소프트웨어의 수요가 증대되었습니다.
- 더 크고 복잡한 소프트웨어 시스템의 수요가 증대되고 있었습니다.

점점 더 요구사항은 복잡해지는 데 산업체에서는 그 수요를 감당하지 못하게 되었고 <u>과도한 비용 지출, 납기일 지연, 부족한 성능, 낮은 신뢰성, 백로그</u>[^3]<u>, 불가능한 유지보수, 제한된 유지보수 비용</u>의 문제가 발생하게 되었습니다.

이 상황을 보고 소프트웨어 위기(software crisis)라고 했습니다. 이때 통계적으로 55%의 프로젝트가 예상 비용을 초과했고, 68%가 계획표를 지키지 못했으며, 88%가 완전히 새로 뜯어고쳐야 했었습니다. 즉, **소프트웨어의 품질이 전반적으로 떨어지면서 납기일 및 한계 비용을 지키지 못하는 상황이 계속 일어났습니다.**

이러한 문제를 해결하기 위해 NATO는 1967년 "소프트웨어 공학"이라는 용어를 만들어냈습니다. 나아가 문제를 해결하기 위한 학회를 소집하였고, 1968년 당대 소프트웨어 위기를 해결하기 위해서 기존 공학 분야에서의 철학과 패러다임을 사용해야 한다고 결론 냈습니다. 그렇게 소프트웨어 공학이 시작되었습니다.

## 필요한 이유

소프트웨어 공학이 필요한 이유는 소프트웨어 개발이 어렵기 때문입니다. 소프트웨어 개발이 어려운 이유는 눈에 보이지 않고, 복잡하며 각 서비스마다 따로 만들어야 하고[^5]  시간이 지나면서 계속 발전한 데다가 개발 과정이 직렬이고 자동화가 불가능하며 의사소통 및 인력 관리가 중요하기 때문입니다. 심지어 전체 테스트 케이스를 전부 검증을 할 수가 없기까지 합니다.

일반적으로 대규모 프로젝트하는 경우를 생각해보겠습니다. 이 경우 주요 어려움으로는 **수백 명의 개발자, 오랜 개발 시간, 모호하고 복잡한 요구사항**등이 있습니다. 먼저 많은 개발자 수는 조직 및 팀 구조를 짜는 것과 의사소통 및 상호 협력의 문제가 있습니다. 그리고 개발 시간이 오래 걸리기 때문에 프로젝트 관리 및 비용ㆍ효과의 산정이 힘듭니다. 그리고 요구사항도 수백 페이지에 달하고, 그 내용이 매우 모호하고 복잡한 경우가 대다수인 데다가 이를 빈번하게 바꾸는 상황에 대응하기가 매우 힘듭니다.

## 정의 및 목표

정리하면 **<u>복잡하고 큰 소프트웨어를 효과적으로 개발</u>하고 <u>유지보수</u>하면서 <u>체계적으로 정리</u>하는 과정이 바로 소프트웨어 공학**입니다. 이러한 소프트웨어 공학에 대해서 Watt Humphrey는 체계적인 정리를 하는 학문이라 하였고, IEEE에서는 체계적인 접근을 위한 학문이라 했으며, D.L.Parnas에서는 다양한 버전의 소프트웨어를 여러 사람이 만드는 과정에 대한 학문, Ian Sommerville은 거대한 소프트웨어를 제작하는 방법에 관한 학문이라 말했습니다. 이런 소프트웨어 공학의 목표는 다음과 같습니다.

1. 품질이 좋은 소프트웨어 시스템
2. 예산 안에서의 최소 비용의 사용
3. 사용자가 만족하는 개발 기간

## 알아야 하는 내용

소프트웨어 공학을 하기 위해서 알아야 하는 내용으로는 개발 과정, 디자인ㆍ코딩ㆍ분석, 도구와 환경의 사용 방법, 프로젝트 관리 방법, 버전 관리, 품질 관리와 나아가 하드웨어 특징과 사람에게 보여주는 요소[^4]를 어떻게 구성할 것인가, 전문적인 의사소통과 문서화가 있습니다. 그리고 여기서 소프트웨어 공학에서 중요한 것은 **문서화**입니다. 왜냐하면, 소프트웨어의 특징으로는 닳지 않고 사람의 눈에 안 보이기 때문에 기록해서 이를 눈에 보이도록 해야하기 때문입니다. 혹자는 소프트웨어 공학을 문서화의 과정이라고 하는 사람도 있습니다.

# 소프트웨어 종류

소프트웨어 종류로는 시스템 소프트웨어, 실시간 소프트웨어, 비지니스 소프트웨어, 공학/과학용 소프트웨어, 임베디드 소프트웨어 등이 있습니다. 정리하면 아래와 같습니다.

|     소프트웨어 종류     | 내 용                                                        |
| :-----------: | :----------------------------------------------------------- |
|시스템|다른 프로그램에 서비스를 제공하기 위해 만들어진 프로그램입니다.<br />(e.g. 운영체제, 드라이버, 파일 관리자 등)|
|실시간|실세계 사건을 실시간으로 분석, 제어, 감독하는 프로그램입니다.<br />이들은 엄격한 시간 제약을 두고 실행되는 특징이 있습니다.<br />(e.g. 군사용 시스템)|
|비지니스|비지니스 업무 처리 또는 의사결정을 쉽게 만드는 프로그램입니다.<br />(e.g. 통상적인 데이터 처리, MIS(정보 관리 시스템) 등)|
|공학/과학용|"수(數) 처리" 알고리즘이라고 할 수 있는 프로그램입니다.<br />(e.g. CAD, 자동차 도로 테스트 등)|
|임베디드|제품이나 시스템에 내장되어 있으면서 사용자나 시스템 자체를 위한<br />특징이나 기능을 구현하고 제어하는 데 사용된다.<br />매우 제한적이고 내밀한 기능을 수행한다.|
{:.table .table-bordered}

---

[^1]: 유지보수는 통상 개발보다 2배 이상의 비용이 들어갑니다.
[^2]: 완벽히 역전이 되는 것은 1984년 즈음입니다.
[^3]: 점점 개발해야 할 사항이 쌓임을 의미합니다.
[^4]: 그래픽 사용자 인터페이스 같은 것이 있습니다.
[^5]: 적합성(conformity)이라고 합니다.