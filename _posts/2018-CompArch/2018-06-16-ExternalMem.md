---
layout: post
title: "[컴퓨터 구조] External Memory"
date: 2018-6-16
excerpt: "외부 메모리에는 어떤 것이 있는 지 알아보도록 한다."
tag:
- Computer Architecture
comments: true
---
출처 : Willian Stallings. (2013). Computer Organization and Architecture. London:Pearson

# External Memory

외부 메모리는 내부 메모리에 비해 고용량의 내용을 보관하기 위해서 사용합니다. 이런 외부 메모리의 종류는 크게 3개로 나뉠 수 있습니다.

- 자기 디스크
    - RAID
    - HDD
- 광학 디스크
    - CD-ROM
    - CD-R
    - CD-RW
    - DVD
- 자기 테이프

## Magnetic Disk

먼저 자기 디스크에 관해서 알아보도록 하겠습니다. 자기 디스크는 자화 물질인 산화철($$Fe_2O_3$$)로 자기 기판을 코팅을 시키도록 합니다. 이러한 기판에는 알루미늄을 사용하기도 합니다. 하지만 현대에는 **유리**에다 산화철을 발라서 동작 시킵니다. 이러한 방식은 아래와 같은 특징이 있습니다.

- 표면의 균일성을 높여주도록 합니다.
    - 이는 신뢰도를 올립니다.
- 표면의 오염을 줄이도록 합니다.
    - 읽고 쓰는 데의 오류를 감소시킵니다.
- 헤드가 뜨는 정도를 좀 더 낮출 수 있습니다.
- 외부변형에 대한 저항 강도가 강해집니다.
- 충격이나 상해로부터 강해집니다.

이러한 자기 디스크는 헤드를 통해 읽고 쓰게 됩니다. 그리고 이러한 읽기 및 쓰기의 도중에 헤드는 정적으로 있으나 플래터는 회전을 하게 됩니다. 각각의 동작 방법에 대해 기술을 하면 아래와 같이 됩니다.

- 쓰기
    - 전류를 코일에 보내어 자기장을 형성 시킵니다.
    - 펄스(pulse)들이 헤드에 보내집니다.
    - 자기 패턴이 표면에 기록되게 됩니다.
- 읽기(전통적 방법)
    - 자기장의 움직임이 코일에 전류를 생산을 합니다.
    - 이 때 코일은 쓰기용 코일과 같은 것을 사용합니다.
- 읽기(현대의 방법)
    - 쓰기 헤더 가까이에 MR 센서[^1]를 활용한 읽기 헤더를 분리해서 둡니다.
    - MR 센서에 다른 자기장의 영향을 차폐를 시키기 위해 쉴드(shield)를 사용합니다.
    - 이러한 MR 센서는 자기장의 방향으로 전기 저항을 발생시키도록 합니다.
    - 이런 MR 센서를 사용한 디자인은 많은 수의 명령을 처리할 수 있습니다.
        - 이는 더 높은 저장 용량과 속도를 가지게 됩니다.

이 내용만으로는 이해가 힘드니 실질적인 모형은 아래와 같습니다.

![HDD](/assets/img/res/2018-CompArch/ExternalMem/HDD.png)

이런 디스크는 원형이기 때문에 속도의 차이 문제[^2]가 발생하게 됩니다. 그래서 하드디스크의 데이터 저장 방법에는 2가지가 있습니다.

- CAV(Constand Angular Velocity) 방식
    - 데이터를 처리하는 방법이 매우 쉽습니다.
    - 데이터의 집적도가 낮으므로 낭비하는 공간이 많습니다.
- Zone들을 사용한 방식
    - 제어 속도를 달리하여 데이터를 처리하여 방법이 복잡합니다.
    - 데이터의 집적도가 높아집니다.

전자는 좌측의 그림과 같이 나타나고, 후자는 우측의 그림과 같이 나타납니다.

![Layout](/assets/img/res/2018-CompArch/ExternalMem/layout.png)

다음은 초창기의 디스크 방식인 윈체스터 디스크 방식입니다.

![Winchester](/assets/img/res/2018-CompArch/ExternalMem/winchester.png)

여기서 `gap`은 섹터와 섹터 사이의 구분자(delimiter)의 역할을 하는 것입니다. 그리고 `ID field`는 이 섹터에 관한 정보를 가집니다. 여기서 유의 사항으로 `synch byte`가 있는 데 이는 동기화를 의미하는 것이 아니라 현재 이 섹터가 가리키는 것이 데이터를 의미하는 것인지 새로운 패턴인지를 확인하는 일종의 프리앰블(preamble)의 역할을 합니다. 그리고 `CRC`에서 오류를 확인을 하도록 합니다. 또한 이런 윈채스터의 하드디스크 특징 중 하나는 헤드가 공기층위에 살짝 떠서 이동하는 데 이 떠 있는 정도는 연기의 입자보다 더 작습니다.

그렇다면 디스크의 속도는 어떻게 재는지 알아보도록 하겠습니다. 이런 디스크는 탐색 시간, 지연 시간, 접근 시간, 전송 비율, 추가 지연 시간들로 나타낼 수 있습니다. 이것들은 아래와 같이 나타날 수 있습니다.

- 탐색 시간(Seek Time)
    - 보통 평균 탐색 시간은 10ms 밑 입니다.
- 회전 지연(Rotate Delay)
    - 15,000 rpm[^3] = 250 r/sec
    - 250 r/sec은 다시 말해 1 회전은 4ms임을 의미합니다.
    - 따라서, 평균 회전 지연은 $$1/(2r)$$이므로 2ms가 됩니다.
- 전송 시간(Transfer Time)
    - 결과 식 : $$T = (b/N) * (1/r)$$
    - b : 전송하는 바이트의 수
    - N : 트랙의 바이트
    - r : 회전 속도
- 총 평균 접근 시간
    - 결과 식 : $$T_a = T_s + 1/(2r) + b/(rN)$$
    - $$T_s$$ : 평균 탐색 시간
    - $$1/(2r)$$ : 평균 회전 지연
    - $$b/(rN)$$ : 전송 시간

그럼 아래의 예제를 위의 식을 활용하여 풀어보도록 하겠습니다.
디스크는 아래의 사양을 가진다고 가정하겠습니다.

- 평균 탐색 시간 : 4ms
- 회전 속도 : 7,200rpm
- 전송 속도 : 512 bytes/sec
- 트랙 당 색터 : 500 sector/track

여기서 위의 각각을 구하면

- 평균 탐색 시간 : 4ms
- 평균 회전 지연 : $$72,000 rpm = 1200 r/sec →1/(2 \times 1200) →약\ 4ms$$

이제 2500개의 섹터를 읽는다고 하도록 하겠습니다. 트랙이 최적화가 되었다는 가정하에 5개의 트랙이 인접해 있을겁니다.(이유 : 500 sector/track이므로 2500 섹터의 읽기는 5개의 트랙으로 구성) 이에 따라, 먼저 첫 번째 트랙을 읽는데 필요한 계산은 아래와 같습니다. 먼저 트랙의 전송 시간을 구하도록 해야합니다. 앞에서 우리는 트랙이 최적화가 되었다고 했으므로 $$b/N = 1$$이 됩니다. 따라서, 아까 평균 회전 시간이 4ms이므로 트랙의 전송 시간은 8ms가 되게 됩니다. 따라서, 아래와 같은 식으로 첫 번째 트랙을 읽는 데 걸리는 시간을 구할 수 있습니다.

$$ 4ms(평균 탐색 시간) + 4ms(평균 회전 지연) + 8ms(트랙 전송)$$

그리고 나머지 4개의 트랙들은 추가적인 탐색 시간이 필요하지 않으므로 아래와 같은 식으로 나타낼 수 있습니다.

$$4(트랙 갯수) \times \{4ms(평균 회전 지연) + 8ms(트랙 전송 시간)\}$$

결과적으로, 총 걸리는 시간은 아래와 같습니다.

$$( 4 + 4 + 8 ) + \{ 4 \times ( 4 + 8 ) \} = 64(ms)$$


## RAID

RAID는 Redundant Array of Independent Disks의 약자입니다. 6개 레벨의 사용법이 있으며, 데이터가 물리적 드라이브간 분산된 것이라 볼 수 있습니다. 각 RAID에 관해서 알아보도록 하겠습니다.

<sub> 참고사항 :  RAID 0, 1, 3, 4, 5, 6, 0+1 그림의 출처는 https://www.golinuxhub.com/2014/04/raid-levels-0-1-2-3-4-5-6-01-10.html 이며 RAID 2는 http://ict.udlap.mx/people/carlos/is215/raid/04_01_02.html 를 따릅니다.</sub>

### RAID 0
리던던트(redundant)를 가지고 있지 않습니다. 데이터를 동일 위치에 줄을 세우는 방식이며, 패리티와 라운드 로빈[^4] 방식을 사용하기 때문에 매우 빠른 속도를 지닙니다. 
![RAID 0](https://4.bp.blogspot.com/-XzJtt5BvN4U/U0UgtzGrntI/AAAAAAAADGk/HkrtBJ67Dao/s1600/raid_0.png)

### RAID 1
디스크가 디스크를 복제(Mirroring)를 합니다. 패리티는 가지고 있지 않습니다. 복구가 매우 간단합니다. 가격이 비쌉니다.
![RAID 1](https://1.bp.blogspot.com/-mgfOF1W2cGo/U0UhDSeEJ0I/AAAAAAAADGs/F9it2MYPdv0/s1600/raid_1.png)

### RAID 2(중요)
디스크들은 서로 동기화가 되며 아주 작은 수의 줄을 가집니다. 오류를 한꺼번에 확인이 가능합니다. 많은 리던던트를 가지고 있습니다. 따라서 가격이 비싸고 사용하지 않는 용량이 있습니다.
![RAID 2](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b5/RAID2_arch.svg/350px-RAID2_arch.svg.png)

### RAID 3
RAID 2와 유사하나 리던던트를 하나만 두어서 해결합니다. 그래서 만약 리던던트 디스크가 고장나는 경우 좋지 못한 일이 발생할 수 있습니다.
![RAID 3](https://1.bp.blogspot.com/-SEy9OmGJIpc/U0UhOUCPaNI/AAAAAAAADG0/kfPG_Pv2AQU/s1600/raid_3.png)

### RAID 4
각각의 디스크는 독립적으로 동작을 하며, 높은 입출력 요구에 좋습니다. RAID3와 유사하나 블럭 단위로 줄을 세우도록 합니다. 패리티는 패리티가 저장되는 디스크에 저장됩니다.
![RAID 4](https://2.bp.blogspot.com/-HgK_O-Lvbs0/U0Uhz4XAF-I/AAAAAAAADG8/WHmCFj-T644/s1600/raid_4.png)

### RAID 5
RAID 4와 같으나 패리티가 모든 디스크에 존재하게 됩니다. 이런 패리티의 할당을 라운드 로빈으로 할당됩니다. 네트워크 서버에서 주로 사용됩니다.
![RAID 5](https://2.bp.blogspot.com/-z6QsYQqZQwg/U0UiqbZsNPI/AAAAAAAADHE/f_Pc2hHkmiU/s1600/raid_5.png)

### RAID 6
2개의 패리티 계산을 사용합니다. 서로 다른 디스크의 분리된 블럭에 저장을 하도록 합니다. 매우 높은 데이터 가용성을 지닙니다.
![RAID 6](https://2.bp.blogspot.com/-avgW4shFNSs/U0UjUOUi2KI/AAAAAAAADHM/-G2VZ2Cfr18/s1600/raid_6.png)

### RAID 0 + 1
일반적으로 가장 많이 사용하는 방식입니다. RAID 0과 RAID 1을 합쳐 제작한 방식입니다.
![RAID 0+1](https://3.bp.blogspot.com/-lOnNZm3AVNU/U0UjbGjAIhI/AAAAAAAADHU/OAtn17Ehfyg/s1600/raid_01.png)


광학 및 자기 디스크는 생략하도록 하겠습니다.

---
[^1]: 자기저항효과소자를 사용한 센서로, 자계의 변화와 자성체의 유무를 전압의 변화로 검출할 수 있습니다.
[^2]: https://ko.wikipedia.org/wiki/각속도
[^3]: revolutions per minutes(분당 회전 수)
[^4]: 순차 순환 방식
