---
layout: post
title: "[네트워크] Internetworking & IP"
date: 2018-10-07
excerpt: ""
tag:
- network
comments: true
---

# 시작하기 전에

먼저 ICT 기술의 발전 과정을 알아보도록 하겠습니다. ICT 기술의 발전은 다음과 같이 진행되었습니다.

### 1세대

Telco(Telephone Company)로 대표되는 전화선에서 사용되는 아날로그 통신이 주축이었습니다.

### 2세대

**TCP/IP**를 사용하는 ISP(Internet Service Provider)와 모바일 네트워크 환경을 제공하는 MSP, 방송용으로 사용하는 네트워크의 3개의 서로 다른 네트워크가 탄생했습니다. 이를 기점으로 CDMA와 같은 디지털 통신이 발달하여 아날로그 통신에서 디지털 통신으로 변화하기 시작했습니다.

### 3세대

무선과 유선의 영역이 통합되면서 점점 표준화의 바람이 불기 시작한 시점입니다. 이 기점으로 아이폰이 등장하게 됩니다.

### 4세대

All-IP, 유비쿼터스, 통합 네트워크가 나타나게 되었고, LTE와 같은 규격이 등장하면서 속도가 점점 빨라지기 시작합니다. 그러면서 IoT(Internet of Things)가 등장하게 되고, 초연결 사회(Hyper Connected Society)로 진입하기 시작하면서 5세대 통신으로 점점 진행합니다.

위에서 언급되는 세대 구분에서 초창기 세대의 통신은 한국 통신으로 비롯되는 국영 기업에 의해서 철저하게 네트워크 서비스 전체가 **폐쇄적으로 수직 구조**로 운영되었습니다. 하지만 현대 세대에는 네트워크 서비스를 담당하는 기업과 네트워크를 제공을 담당하는 기업이 분리되고 **수평 구조**로 운영됩니다. 심지어 최근은 IoT+Cloud+Big Data+Mobile로 대표되는 ICBM이 점점 커지면서 더더욱 네트워크의 중요성이 나날이 증대되게 됩니다.

이런 네트워크를 이해하기 위해서 우리는 데이터 통신 과목을 선행하게 됩니다. 선수과목인 데이터 통신에서는 미디어의 전송 방법과 디지털 통신 및 신호의 인코딩 기술, 데이터 링크의 제어, 다중화(Multiplexing), 서킷 및 패킷 스위칭, 라우팅, 혼잡 제어(congestion control), WAN, LAN과 같은 것에 관해서 알아봤습니다. 따라서, 해당 내용은 따로 설명하지 않을 수 있음을 유의 부탁드립니다.

지난 데이터 통신을 아주 조금만 더 확인을 해보면 데이터 통신이라는 것 자체가 매우 복잡한 과정을 운용하게 됩니다. 따라서 이를 한 번에 운용하는 것은 매우 힘든 일이라고 할 수 있습니다. 그래서 이를 이해하는 가장 좋은 방법은 **분할 정복(Divide and Conquer)을 통한 운용**입니다. 이러한 생각을 바탕으로 계층 구조(Layered Architecture)에 따른 통신 방법을 고안해냈고, 각 계층에서의 통신 방법에 대한 정의를 프로토콜(Protocol)이라 정의하였습니다. 이런 바탕으로 **계층 프로토콜 구조(Layered Protocol Architecture)**가 나오게 되었습니다. 그리고 이러한 구조의 표준을 제정하고자 여러 시도가 있었고, 결과 이론적 표준으로 OSI 7 구조가 나타나고, 실질적 표준으로 TCP/IP 프로토콜 구조가 나오게 됩니다. 이는 아래와 같은 구조로 만들어집니다.

![model](/assets/img/res/2018-network/IP/model.png)

그리고 이러한 구조는 러시아의 인형인 마트료시카(Matryoshka)와 같이 데이터를 보낼 때는 상위 계층에서 하위 계층으로 일종의 포장을 합니다. 그리고 포장을 푸는 과정에는 하위 계층에서 상위 계층으로 가면서 점점 풀도록 합니다. 여기서 각 계층에서의 데이터 단위를 보고 PDU(Protocol Data Unit)이라 하고, 이런 PDU는 실질적인 데이터를 가지고 있는 SDU(Service Data Unit)와 해당 계층의 임무를 수행하기 위한 제어정보를 가지고 있는 PCI(Protocol Control Information)로 구성됩니다. 이제 이와 같은 내용을 바탕으로 네트워크를 이제 확인해보도록 하겠습니다.

# Inter-networking

인터네트워킹(Inter-networking)은 물리적, 지리적으로 분리되어있으며, 나아가 서로 다른 기술을 사용하는 네트워크를 **논리적으로 하나의 네트워크를 사용하는 방법**을 이야기합니다. 이런 인터네트워킹의 수행을 위해서 내부 연결을 위해 사용하는 장치로는 OSI 7 구조를 바탕으로 아래와 같습니다.

- 리피터(Repeater): 물리 계층 간의 연결
- 브리지(Bridge): 데이터 링크 계층 간의 연결
- 라우터(Router): 네트워크 계층 간의 연결
- 게이트웨이(Gateway): 응용 ~ 전송 계층 간의 연결

이런 각각의 장치를 사용하는 이유는 아래 2가지의 문제를 해결하기 위함입니다.

1. 이질성(Heterogeneity)
2. 확장성(Scalability)

먼저 이질성은 ‘서로 다른 장치 간에 통신을 어떻게 할 것인가를 해결하는 과정’이고, 규모 확장성은 네트워크에 장치가 추가되어도 문제가 없게 만들어야 함을 이야기합니다. 먼저 이를 해결하기 위해 사용되는 브릿징(Bridging)과 라우팅(Routing)에 관해서 알아보도록 하겠습니다. 브릿징의 경우, IEEE 802 LAN이라는 **공통 기술**을 사용하는 망들을 연결하여 논리적으로 하나의 연동 망을 형성하는 것을 의미합니다. 그리고 라우팅의 경우 네트워크 계층에서 물리 망의 다양성, 이질성을 효과적으로 대체하기 위해서 만들어 인터네트워킹을 도와주도록 합니다.

여기서 이제 IP(Internet Protocol)라는 개념이 나오게 됩니다. 예를 들어보도록 하겠습니다. 아래와 같은 집합이 서로 의사소통(실선으로 표기)을 하려면 각 한 명이 대응하는 각 나라의 언어를 배워야만 합니다.

![translate1](/assets/img/res/2018-network/IP/bare_translate.png)

이런 방식의 문제는 미국인 한 명이 양쪽에 추가되면 새로운 연결을 전부 만들어야 합니다. 따라서 새로운 방식이 나올 필요가 있습니다. 그렇다면 만약 어떤 세계 표준어가 있고 전 세계 사람이 그 언어를 자유롭게 구사할 수 있다면 미국인 한 명이 들어와도 큰 문제가 되지 않을 것입니다. 이를 그림으로 표현하면 아래와 같이 될 수 있습니다.

![translate2](/assets/img/res/2018-network/IP/translate.png)

결과적으로 흔히들 모래시계(Hour Glass) 모형이라 하는 위와 같은 방식이 훨씬 컴퓨터에 친화적인 방법으로 비용이 많이 들지 않는 방법입니다. 그렇기에 우리는 컴퓨터에 세계 표준어와 같은 것을 만들어야 합니다. 하지만 하드웨어적으로 이를 구현하기로는 많이 힘듭니다. 따라서 **이는 소프트웨어로밖에 못 만들게** 됩니다. 즉, 우리는 **공통 논리(Common Logical)**를 만들 필요가 있게 됩니다. 그렇게 해서 나오게 된 것이 아이피(IP)입니다.

약간 부차적인 이야기인데 Internet하고 internet은 이제는 별 구분이 없지만, 엄밀하게 그 두 개는 다르게 봐야 합니다. 먼저 Internet은 아이피를 사용하는 네트워크를 지칭하고, internet은 네트워크를 사용하는 것을 이야기합니다.

# 아이피 서비스 모델

아이피 서비스 모델은 아래와 같은 특징을 갑니다.

1. 모든 물리 네트워크가 제공할 수 있는 **단순한(Simple) 서비스**
2. 연결(Connection)[^1] 위주가 아니라 **데이터 그램(Datagram)**[^2]을 바탕으로 하는 서비스
3. 보내는 데에 **최선의 노력(Best-effort)**을 하는 서비스

여기서 매우 중요한 내용이 보내는 데에 최선의 노력을 하는 서비스라는 것입니다. **이는 썩 좋은 말이 아닙니다.** 이를테면 어느 택배 회사가 “고객님에게 저희가 보내는 것은 최선을 다하겠습니다.” 그러면 그 택배 회사는 썩 믿을만한 회사라고 볼 수 없습니다. 왜냐하면, 보내는 것을 최선을 다한다는 거지 그 내용이 “안전하게 문제없이 되었는지” 또는 “도착이 제대로 되었는지”를 신경 쓰면서 보내겠다는 것은 아니기 때문입니다. 결과적으로, 보내는 데에 최선의 노력에는 아래의 문제가 발생하고, 아이피는 그러한 **문제들을 전혀 신경 쓰지 않을 것**입니다.

- 패킷을 잃어버릴 수도 있고, 배송 순서가 뒤죽박죽에 중복될 수 있습니다.
- 패킷은 오래 걸려서 도착 안 할 수도 있습니다.

하지만 아이피 서비스 모델이 너무 단순해서 사람들이 좋아했고, 결국 아이피를 필두로 한 인터넷이 성공하게 됩니다. 결국, 아이피가 주요 프로토콜이 되었고, 아이피 데이터 그램이 배송 과정의 일부로 포장되어 **하부 물리 망(ex. 이더넷)을 통해서 보내지게 됩니다.**[^3] 아래가 아이피 데이터 그램의 모형으로 총 20바이트(4바이트 × 5)의 헤더를 가진 데이터 그램입니다.

![IP Datagram](http://mars.netanya.ac.il/~unesco/cdrom/booklet/HTML/NETWORKING/IMAGES/ipheader.gif)

# 네트워크 주소의 종류

네트워크 주소로는 2개의 주소가 존재합니다. 하나는 물리 주소(Physical Address)이고 다른 하나는 논리 주소(Logical Address), 아이피 주소입니다.

## 물리 주소

48bit의 IEEE MAC(Medium Access Control) 주소로 대다수의 물리 망은 이를 바탕으로 물리 주소를 특정하도록 합니다. 계층 구조이며 `제조사(23bit) + 시리얼 번호(23bit)`로 구성됩니다.

## 논리 주소

이는 아이피에 관계된 주소로 계층 구조이며, `Network ID+Host ID` 합쳐 32bit로 구성됩니다. 이런 논리 주소의 할당은 NIC(Network Information Center)에서 네트워크 주소 블록(Block)을 ISP에 제공합니다. 이 내용을 바탕으로 ISP는 도메인(Domain)과 같은 것들에 적절한 네트워크 주소를 할당을 해주도록 합니다. 그리고 이렇게 할당받은 네트워크 주소를 호스트(Host)의 요청에 따라 호스트 주소를 할당을 해주도록 합니다.

이렇게 호스트에게 할당하는 방식으로 고정 할당 방식이 있고, 동적 할당 방식이 있습니다. 전자의 경우 시스템 관리자에 의해서 일일이 하나하나 적은 파일을 바탕으로 고정되어 할당되게 됩니다. 하지만 후자의 경우 DHCP(Dynamic Host Configuration Protocol)를 통해서 서버로부터 동적으로 할당을 받게 됩니다. 이는 `Plug-and-Play` 방식이라 일반 사용자의 접근이 훨씬 쉽습니다. 좀 더 이제 상세하게 보겠습니다.

### IPv4

**클래스 기반**의 계층 구조로 구성되어 있습니다. ‘뭐가 도대체 계층인가?’를 확인해보면 위에서 언급한 네트워크+호스트의 주소 구성 방식을 가지기 때문입니다. 이렇게 구성을 한 이유는 확장성을 보장하기 위해서입니다. 이런 계층 주소 구조의 주요 특징으로는

- 동일 네트워크의 호스트는 같은 네트워크 아이디와 네트워크 주소를 가집니다. 따라서 물리 주소는 매우 중요한 요소 중 하나입니다.
- 확장성을 고려한 디자인은 라우팅 표(Table)를 호스트 단위가 아닌 네트워크 단위로 구성할 수 있습니다.

이런 클래스는 A~E로 나뉘며 각각은 아래와 같은 특징을 가지게 됩니다. A ~ C는 네트워크의 크기를 고려하여 큰 것은 A를 작은 것은 C를 주는 방식으로 배정하도록 합니다. D는 다자간 통신용으로 만들어진 클래스이고, 현재 E는 사용은 되지 않으나 미래를 위해서 남겨놓은 주소들입니다. 각각의 클래스는 아래와 같습니다. 여기서 수용량은 호스트 아이디가 네트워크 수용량이 됩니다.

![network class](https://xn--3e0bx5euxnjje69i70af08bea817g.xn--3e0b707e/images/renewal/visual102-02.jpg)

만약 어떤 라우터가 2개의 네트워크를 구성하는 경우 2개의 네트워크 아이디를 가져야 합니다. 그리고 하나의 NIC(Network Interface Card)는 하나의 아이피 밖에 못 가지기에 이 라우터는 2개의 NIC를 가지게 됩니다. 결과적으로, 라우터가 네트워크를 N개 구축을 할 때는 N개의 네트워크 아이디를 가지고 N개의 NIC를 가지는 것을 알 수 있습니다.

그리고 이러한 아이피에는 특수한 아이피가 몇몇 존재합니다. 그 내용은 아래 표와 같습니다.

| 주소 | 아이피 | 내용 | 
|:----------:|:-----------:|-------|
|네트워크|164.125.0.0| 네트워크 그 자체를 식별하기 위해 사용됩니다. |
|브로드<br>캐스트<br>(Broadcast)|255.255.255.255|전 세계 네트워크에 데이터를 보내도록 합니다.|
|            | 164.125.255.255| 164.125로 네트워크 아이디에 해당하는 곳에다가 네트워크 데이터를 모두에게 보내겠음을 의미합니다.|
|루프 백<br>(Loopback)| 127.\*.\*.\*| 자신을 목적지로 하는 주소로 127.0.0.1을 주로 사용합니다. 일반 호스트에 할당해서는 절대 안 됩니다.|
|      | 0.0.0.0|아이피가 할당되지 않은 상황에서 부트스트랩(Bootstrap) 시 시작 주소(source address)로 사용됩니다.
{:rules="groups"}

## Sub-netting

서브넷팅(Subnetting)은 흔히들 말하는 서브넷 마스크(Subnet Mask)를 실시하는 과정입니다. 위에서 배웠듯이 아이피 주소는 네트워크 아이디와 호스트 아이디로 구성됨을 알 수 있습니다. 여기에서 호스트 아이디 부분의 일부분을 빼서 서브넷 아이디로 만들어주고 **네트워크 아이디 + 서브넷 아이디**를 **서브넷 마스크** 값을 통해 알 수 있습니다.

이때, 서브넷 아이디의 길이는 서브넷 마스크의 값에 의해 결정됩니다. 예를 들어, 164.125.38.0/24의 의미는 서브넷 마스크의 길이가 24 비트 임을 의미합니다. 이를 테면, 서브넷을 9 비트 만큼 사용하고 싶을 때는 255.255.255.128로 하도록 합니다. 왜냐하면, 앞의 255.255를 통해서 네트워크 아이디를 구할 수 있고, 이제 남은 255.128을 2진수로 표현을 하게 되면 1111 1111 1000 0000이 되게 됩니다. 여기서 1이 총 9개가 있으므로, 우리는 서브넷 아이디의 길이가 9 비트 임을 알 수 있습니다.

## ARP

응용 프로그램 입장에서는 아이피만 알면 되지만 정확하게 데이터 그램을 규격에 맞게 보내기 위해서는 변형이 필요합니다. 하지만 이 내용은 아이피 주소만으로 아는 것은 불가능합니다. 따라서 MAC 주소를 알 필요가 있게 되었고, ARP(Address Resolution Protocol)가 도입되게 되었습니다.

ARP와 RARP 프로토콜은 아이피와 MAC 계층의 변환을 담당합니다. 이것의 동작은 아래와 같습니다.

3. 임의의 호스트(A)에서 특정 아이피의 MAC을 찾는다고 LAN을 통해 브로드캐스트[^4]를 실시합니다.
4. 브로드캐스트 결과 특정 아이피에 해당하는 호스트(B)가 ARP를 받게 됩니다.
5. 본인(B)의 MAC를 임의의 호스트로 보내주도록 합니다.

결과적으로, ARP는 **논리 주소인 아이피를 통해 물리 주소 MAC을 얻는 과정**이라고 볼 수 있습니다. 추가로 이렇게 구한 ARP의 응답 결과를 ARP 캐시에 저장해서 동일 위치(B)에 보낼 때 좀 더 빠르게 보낼 수 있게 만들어서 통신 효율을 높여주도록 합니다. ARP의 패킷은 아래와 같이 구성됩니다.

![ARP](http://3.bp.blogspot.com/-HrRfcl_YclA/ViKcN4V0bdI/AAAAAAAABK0/LuZwYnArfio/s1600/2015-10-18_00-36-06.png)

그리고 위의 동작에 따른 결과 예제는 아래와 같습니다.

![ARP_REQ](/assets/img/res/2018-network/IP/ARP_req.png)

이런 ARP에도 문제점이 없지는 않습니다. 이를테면 브로드캐스트가 되는 점을 악용해서 누군가가 **ARP 응답을 속여 보내는 경우**가 발생했을 때, 이를 막을 방법은 사실상 없다고 볼 수 있습니다.

## 포워딩과 라우팅

포워딩(Forwarding)과 라우팅은 **구분해서** 생각해야 합니다. 포워딩은 포워딩 및 라우팅 표를 이용해서 입력받은 패킷을 **적절한 출력으로 보내는 과정**이라고 하면, 라우팅은 포워딩 및 라우팅 **표를 제작하는 과정**입니다. 이런 포워딩은 아래와 같은 순서로 진행되게 됩니다.

6. 도착 아이피 주소를 받음
7. 포워딩/라우팅 표에서 네트워크 도착점과 도착 주소와 네트워크 마스크(Netmask) 값을 AND 연산 취한 것의 값이 같은 것을 찾도록 합니다.
8. 2로 인해 찾은 내용 중 가장 마스크가 긴 것이 선택되도록 합니다. 다음에 이웃 라우터로 가는 게이트웨어(Gateway) 주소를 추출하고 데이터 그램을 지정된 인터페이스를 통해서 다음 지역으로 이동시키도록 합니다.

## 부족한 아이피 주소

아이피 주소도 IoT 시대가 도래하면서 벌써 그 양이 거의 다 차게 되었습니다. 그래서 이를 해결하는 여러 방법이 나왔는 데 그 방법에 관해서 알아보도록 하겠습니다. 먼저 **근본적인 해결책**으로 새로운 좀 더 긴 아이피 체계를 만들면 됩니다. 그렇게 해서 32 비트의 IPv4를 대체해서 **128 비트의 IPv6**가 나오게 됩니다. 그리고 이러한 IPv6가 스마트폰과 IoT 장치에서는 기본값으로 설정이 됩니다. 문제는 기존의 대부분 시스템이 IPv4를 사용하기에 적응하기에 시간이 걸리게 될 것은 자명한 일입니다. 그렇게 해서 나오게 된 **실용적이나 일시적인 해결책**이 **사설 아이피(Private IP)와 NAT(Network Address Translation)**을 사용하는 방식입니다. 여기에 관해서 이제 알아보도록 하겠습니다.

### NAT 종류

NAT의 종류는 크게 고정 NAT와 동적 NAT, PAT(Port Address Translation)이 있습니다. 

#### 고정 NAT

사설 주소와 공용 주소를 1:1로 대응시키는 방법으로 사설 네트워크 안에서 서버를 사용하는 경우 매우 유용하게 사용할 수 있습니다. 외부 접근이 간편한 장점이 있습니다.

#### 동적 NAT

동적으로 할당 및 대응을 시키는 방법으로 공용 주소가 필요하면 공용 주소가 주소 풀(pool)에서 가져와서 동적으로 할당을 해버리도록 합니다.

#### PAT
NAT 종류 중 가장 흔한 종류로 대부분의 홈 게이트웨이(Home Gateway)가 이 방식을 채택하였습니다. PAT 방식은 오로지 하나의 공용 ip만 사용합니다. 이 경우에 각 컴퓨터의 분류는 서로 다른 호스트 또는 사설 주소에 대응하는 32 비트의 TCP/UDP 단말(end-point)인 포트에 대응을 시켜버리도록 합니다. 아래 그림 같은 NAT 변환 테이블이 있는 경우에 밑의 순서와 같은 방식으로 동작하게 됩니다.

| 공용 주소|포트 | 사설 주소|포트 | 
|:----------:|:-----------:|:----------:|:-----------:|
|138.76.29.7|5001|10.0.0.1|3345|
|138.76.29.7|5018|10.0.0.1|5001|
|138.76.29.7|5023|10.0.0.2|3345|
{:rules="groups"}

9. 10.0.0.1, 3345번 포트 호스트가 128.119.40.186, 80번 포트로 보내주도록 합니다.
10. NAT 라우터가 데이터 그램의 시작 주소를 10.0.0.1, 3345번 포트에서 138.76.29.7, 5001번 포트로 테이블을 변경해주도록 합니다.
11. 138.76.29.7, 5001번 포트로 간다고 이야기하는 외부 응답을 받게 됩니다. 여기서 중요한 부분은 5001번 포트가 **유지된다는 점**입니다.
12. 그리고 NAT 라우터는 데이터 그램을 138.76.29.7, 5001번 포트에서 10.0.0.1, 3345번 포트로 변경을 해주도록 합니다.

## DNS(Domain Name Service)

숫자로 된 아이피는 일반인들이 이해하기에 절대 쉽지 않습니다. 따라서 이를 쉽게 이해하게 만들기 위해서 의미를 쉽게 알 수 있는 **계층적(Hierarchical)이고, 분산(Distributed) 구조**인 도메인이 나오게 되었습니다. 이런 도메인의 네임 서버의 저장 상태를 확인하고 싶은 경우에 `nslookup` 명령어를 통해서 확인할 수 있습니다.

## 파편화(Fragmentation)와 재조립(Reassembly)
각 물리 장치들은 MTU(Maximum Transmission Unit)이라 불리는 전송 한계 용량(FDDI: 4500 바이트, Ethernet: 1500 바이트)이 있습니다. 따라서 이를 보낼 때는 데이터 그램을 파편화를 하고 재조립을 하는 과정이 필요합니다. 이때, 데이터 그램의 `flag`와 `offset`을 활용해서 그 데이터 그램이 현재 파편화가 되어있고, 몇 번째 데이터에 해당하는 항목임을 알려주도록 합니다. 데이터 그램의 데이터 이동은 아래와 같습니다.

![fragmentation](http://www.tcpipguide.com/free/diagrams/ipfragmentation.png)


---
[^1]: 연결 위주의 서비스 예제로 스트림(Stream)이 있습니다.
[^2]: http://www.ktword.co.kr/abbr_view.php?nav=&m_temp1=634&id=418
[^3]: 즉, 아이피 자체로 보내지는 것은 아니라는 것을 의미합니다.
[^4]: Unicast→하나에 보내기, Multicast→적절한 인원에게 보내는 것, Broadcast→모두에게 보내는 것